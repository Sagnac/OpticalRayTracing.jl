var documenterSearchIndex = {"docs":
[{"location":"Plotting Examples/#Plotting-Examples","page":"Plotting Examples","title":"Plotting Examples","text":"Plotting is supported with the installation of any Makie backend.","category":"section"},{"location":"Plotting Examples/#Ray-Trace-Plots","page":"Plotting Examples","title":"Ray Trace Plots","text":"Supported keyword arguments are:\n\ntheme (using Makie's theme customizability);\nray_colors (a two-tuple of the marginal & chief ray colors);\nsurface_color (for the optical element surfaces & image plane);\nanything Makie's lines accepts.\n\nUsing the mutating rayplot! version will draw on top of the current figure.\n\nusing GLMakie\n\nsurface_color = :white\nray_colors = (:cyan, :red)\n\nrayplot(system; theme = theme_black(), surface_color, ray_colors)\n\nrays = raytrace(system, -24.0, -1.5 * system.f)\nfig = rayplot(rays)\nrays = raytrace(system, 24.0, -1.5 * system.f)\nrayplot!(rays)\n\nsurface = [Inf 0.0 1.0; -100.0 0.0 -1.0]\nsystem = solve(surface, fill(30.0, 2), 21.0)\n# traces real rays\nfig = caustic(system; theme = theme_black(), surface_color)\n\n(Image: rayplot) (Image: rays) (Image: caustic)","category":"section"},{"location":"Plotting Examples/#Aberration-Plots","page":"Plotting Examples","title":"Aberration Plots","text":"The fan plots are interactive and include a slider which allows dynamic adjustment of the field.\n\nusing GLMakie\n\nwavefan(W)\nrayfan(W, system)\nfield_curves(W, system)\npercent_distortion(W, system)\nspot_diagram(W, system)\nspot_diagram(full_trace(system, 0.0)) # using real rays\n\n \n(Image: wavefan) (Image: rayfan)\n(Image: field_curves) (Image: percent_distortion)\n(Image: spot_diagram) (Image: real_spot_diagram)","category":"section"},{"location":"#OpticalRayTracing.jl","page":"OpticalRayTracing.jl","title":"OpticalRayTracing.jl","text":"Ray tracing, optical system solving, and aberration analysis.\n\n\n\nThis package is meant to be an initial design prototyping tool.","category":"section"},{"location":"#Installation","page":"OpticalRayTracing.jl","title":"Installation","text":"using Pkg\nPkg.add(url = \"https://github.com/Sagnac/OpticalRayTracing.jl\")","category":"section"},{"location":"#Sample-usage","page":"OpticalRayTracing.jl","title":"Sample usage","text":"using OpticalRayTracing\n\n# Tessar lens, units in mm; layout from Hecht's Optics\nsurfaces = [\n    # R        t        n\n    Inf        0.0      1.0\n      16.28    3.57     1.6116\n    -275.7     1.89     1.0\n     -34.57    0.81     1.6053\n      15.82    2.345    1.0\n    Inf        0.905    1.0\n    Inf        2.17     1.5123\n      19.2     3.96     1.6116\n     -24.0     0.0      1.0\n]\n\n# Clear aperture semi-diameters\na = [9.5, 9.5, 9.0, 9.0, 7.63, 8.5, 8.5, 8.5]\n\n# image height\nh′ = 21.5\n\nsystem = solve(surfaces, a, h′)\n\nsystem.M # vertex matrix","category":"section"},{"location":"Paraxial Ray Tracing/#Paraxial-Ray-Tracing","page":"Paraxial Ray Tracing","title":"Paraxial Ray Tracing","text":"The raytrace function provides methods for tracing over a given system or lens while the transfer function provides convenience methods for working with transfer matrices.\n\nLenses can be computed either by passing a surface matrix, as in Lens(surfaces), or directly by using the Lens(lens_matrix, refractive_indices) constructor.\n\n# telephoto objective comprised of two thin lenses in air\nlens = Lens([\n    # t/n   # power\n    0.0      0.02\n    25.0    -0.02\n], ones(3))\n\ny, nu = 1.0, 0.0\n\nraytrace(lens, y, nu)\n\n# object height\nh = 10.0\n# signed object distance from vertex\ns = -100.0\nnothing # hide\n\nraytrace(system, h, s)\n\n(; f) = system\nFFL, BFL = system.EFFD, system.EBFD\n# positive distance from front vertex\nτ = f + abs(FFL)\n# positive distance from back vertex\nτ′ = f + BFL\nu = 0.07\n\n# 2f-2f system\ntransfer(system.M, [0.0, u], τ, τ′)\n\nIn addition, general transfer matrices can be directly constructed by passing a Lens to the TransferMatrix constructor.","category":"section"},{"location":"Optimization/#Optimization","page":"Optimization","title":"Optimization","text":"Constraint based optimization can be carried out by specifying which surface parameters to vary and which system properties to aim for as well as which third order aberrations to minimize.\n\n# you can specify a vector of integers corresponding to linear indices,\n# or a CartesianIndex vector\nv = [2:5; [8, 9]] # this varies only the curvatures for the example lens\n# maps System fields to desired values\nconstraints = Dict(:f => system.f)\n# the following two are optional,\n# if not provided a simple mean over the five Seidel coefficients is taken\naberr = [:W040, :W131, :W222]\nweights = [2.0, 2.0, 1.0]\nnew_system = optimize(system, v, constraints, aberr, weights)\n\nnew_system.layout\nw = aberrations(new_system)\n\nNote that this employs a rudimentary optimization procedure meant to provide a rough initial numerical solution; as a result the constraint values might not be met exactly.","category":"section"},{"location":"Vignetting Analysis/#Vignetting-Analysis","page":"Vignetting Analysis","title":"Vignetting Analysis","text":"Given a system or ray bundle and a set of apertures this package provides a basic tool for evaluating vignetting criteria at each aperture. Along with identifying, by index, which apertures cause partial or full vignetting, the returned Vignetting data structure holds a 5 column semi-diameter matrix in its M field which contains:\n\nThe provided aperture size;\nThe marginal ray limit: the size at which the aperture becomes the stop due to limiting the on-axis ray bundle;\nThe size necessary for no vignetting to occur;\nThe size at which the half-vignetting condition is satisified;\nThe size at which the aperture clips the entire off-axis ray bundle; this is the minimum aperture size at which the given field of view is still supported down to approximately zero irradiance.\n\nIn addition, the maximum system field of view for the unvignetted, half-vignetted, and fully-vignetted cases is determined for the input aperture sizes.\n\nQuerying the FOV field extracts the maximum supported full fields of view in degrees, paraxial principal ray slopes, and the corresponding image heights for all three vignetting conditions as a matrix with the rows corresponding to the conditions and the columns to the fields, slopes, and heights, respectively.\n\nIn essence, the M matrix represents the supported aperture sizes for each case given the system field of view and the FOV matrix corresponds to the maximal fields for the given aperture sizes.\n\nAny NaNs in the M matrix signify that there is no possible size which fits the criteria due to the aforementioned limiting factor.\n\nvig = vignetting(system)\n\n# FOVs, slopes, heights\nvig.FOV\n\nThere is also support for analyzing a traced RayBasis.","category":"section"},{"location":"Real Ray Tracing/#Real-Ray-Tracing","page":"Real Ray Tracing","title":"Real Ray Tracing","text":"This package provides several basic functions for tracing real rays.\n\nThe following traces a real ray through the surfaces with initial height y and initial angle U.\n\ny = 7.0\nU = 0.05\nraytrace(surfaces, y, U, RealRay)\n\nAnd this finds the real marginal ray.\n\ntrace_marginal_ray(system)\n\nIn addition, the amount of spherical aberration produced from a real ray trace can be quantifed.\n\nThe following computes the transverse ray errors and returns vectors with the ray heights at the exit pupil and the ray errors at the paraxial plane.\n\ny, ε = TSA(system)\nε[end]\n\nThese can then be used to approximate, using linear least squares, the coefficients to a tangential ray aberration expansion of the form:\n\nε = By³ + Cy⁵ + Dy⁷ …\n\ndegree = 9\nSA(y, ε, degree)","category":"section"},{"location":"Aspheric Surfaces/#Aspheric-Surfaces","page":"Aspheric Surfaces","title":"Aspheric Surfaces","text":"There is support for tracing over aspheric surfaces by specifying the base sphere radius of curvature at the vertex R, the conic constant K, and any optional, additional surface functions (e.g. polynomials) p.\n\nThis can be done either by passing keyword arguments for the latter two parameters to the real raytrace methods or by using the aspheric Layout constructor:\n\n# example for a single surface, including object space\nR = [Inf, -100.0]\nt = [0.0, 0.0]\nn = [1.0, -1.0] # reflector\nK = [1.0, -0.7] # elliptical profile, prolate spheroid surface\np = [zero, y -> y ^ 4 / R[2] ^ 4] # fourth order surface sagittal correction\nsurfaces = Layout{Aspheric}(; R, t, n, K, p)\n\nThe fourth column refers to the conic constants for each surface. There's also a Layout{Aspheric}(M) constructor which supports specification of the full 4 column matrix directly instead of using keyword arguments if the surface profiles are pure conic sections with no additional polynomial correction.","category":"section"},{"location":"Pupil Sampling/#Pupil-Sampling","page":"Pupil Sampling","title":"Pupil Sampling","text":"Real rays can be traced over the entirety of the pupil rather than just the meridional direction in order to compute the RMS spot size in reference to the centroid from a set of geometric ray errors at the image plane.\n\n# method signature: full_trace(system, H, k_rays, focus)\nε = full_trace(system, 0.0) # on-axis\n\nThe second argument specifies the normalized field parameter, the third the number of rays to trace, and the fourth the focus position which defaults to the paraxial image plane.\n\nThe real spot_diagram can then be plotted using Makie.\n\nBecause transverse ray errors are proportional to the gradient of the wavefront error the wavegrad function can then be used to scale the full_trace result and return the wavefront partial derivative vectors in waves. ε also holds the corresponding pupil polar coordinates in the r and t fields so that they can be used along with the gradient to fit the geometric data to Zernike polynomials.","category":"section"},{"location":"Seidel Aberrations/#Seidel-Aberrations","page":"Seidel Aberrations","title":"Seidel Aberrations","text":"The total third order system coefficients can be extracted by querying the relevant WIJK fields. In addition, chromatic aberration can be quantified for a given δn dispersion vector. The results are optical path differences in waves at the d spectral line for a system in mm; the wavelength parameter can also be tuned.\n\n# for an object \"at infinity\"\n# -- collimated rays, maximum paraxial field of view, focusing at the focal point\nW = aberrations(system)\n\nThe return value holds the relevant metadata in an Aberration structure which can be evaluated over the pupil if called with normalized polar coordinates and a normalized field value. In addition, transverse ray error functions can be constructed and evaluated as well.\n\nH = 0.7;\nx = 0.3;\ny = 0.4;\nW(0.7, π/4)\nεx = RayError{Tangential}(W, system)\nεy = RayError{Sagittal}(W, system)\nε = RayError{Skew}(W, system)\nεx(x, H)\nεy(y, H)\nε(x, y, H)\n\nThe long form named fields (spherical, coma, astigmatism, etc.) hold the per surface coefficient vectors. W220P / petzval, W220T / tangential, & W220 / sagittal refer to the respective field curvatures while the W020 & W111 coefficients refer to defocus & tilt from axial & lateral color, respectively.\n\nW.spherical\n\nThird order coefficients can also be computed for a given object height & axial position by passing a RayBasis instead of a System:\n\nrays = raytrace(system, 10.0, -system.f + system.EFFD)\nW_4f = aberrations(surfaces, rays)","category":"section"},{"location":"API/#OpticalRayTracing.Lens","page":"API","title":"OpticalRayTracing.Lens","text":"Lens(surfaces::AbstractMatrix)\n\nConstruct a lens from a 3 column surface matrix where the first column corresponds to the radii of curvature, the second column to the thicknesses, and the third to the refractive indices.\n\nThe computed result wraps a two column lens matrix where the first column refers to the reduced thickness τ = t / n of the distance prior to the surface and the second column refers to the surface power.\n\njulia> Lens([\n           Inf 0.0 1.0 # object space\n           50.0 3.0 1.5\n           -50.0 0.0 1.0\n       ])\n2×2 Lens:\n 0.0  0.01\n 2.0  0.01\n\n\n\nLens(M, n)\n\nConstruct a lens directly from a two column lens matrix M containing the reduced thicknesses and surface powers corresponding to a refractive index vector n.\n\njulia> Lens([0.0 0.01; 2.0 0.01], [1.0, 1.5, 1.0])\n2×2 Lens:\n 0.0  0.01\n 2.0  0.01\n\nSee also: compute_surfaces.\n\n\n\n\n\n","category":"type"},{"location":"API/#OpticalRayTracing.SA","page":"API","title":"OpticalRayTracing.SA","text":"SA(y::Vector, ε::Vector, degree::Int)\n\nFits spherical aberration transverse ray errors to a polynomial of the given degree using linear least squares. y & ε are the XP heights and ray errors returned by TSA. The returned vector corresponds to the coefficients for a tangential ray aberration expansion of the form: ε = By³ + Cy⁵ + Dy⁷ …\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.TSA","page":"API","title":"OpticalRayTracing.TSA","text":"TSA(system, [k_rays::Int])\n\nComputes the transverse ray aberration errors for spherical aberration using a real ray trace. k_rays controls how many rays are plotted. Returns vectors with the ray heights at the exit pupil and the ray errors at the paraxial plane.\n\nSee also: SA, caustic, raytrace.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.aberrations","page":"API","title":"OpticalRayTracing.aberrations","text":"aberrations(system, [λ], [δn])\n\nCompute the third order wavefront error coefficients based on Seidel sums for a given system or ray basis. Results are in waves at the d-line by default. The dispersion vector δn allows calculation of chromatic aberration.\n\nThe returned Aberration type holds the system totals in the WIJK fields (e.g. W040) while the per surface contributions are held in the long form fields (e.g. spherical).\n\nThe coefficients assume a positive valued field.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.caustic","page":"API","title":"OpticalRayTracing.caustic","text":"caustic(system, [k_rays::Int]; [theme], kwargs...)\n\nTraces real rays and plots the caustic extended to either the paraxial or marginal focus. Requires using a Makie backend. k_rays controls how many rays are plotted.\n\nSee also: solve, raytrace, trace_marginal_ray.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.compute_surfaces","page":"API","title":"OpticalRayTracing.compute_surfaces","text":"compute_surfaces(lens::Lens)\n\nCompute the surface matrix from a given Lens.\n\njulia> compute_surfaces(Lens([0.0 0.01; 2.0 0.01], [1.0, 1.5, 1.0]))\n3×3 Matrix{Float64}:\n  Inf   0.0  1.0\n  50.0  3.0  1.5\n -50.0  0.0  1.0\n\nSee also: Lens.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.field_curves","page":"API","title":"OpticalRayTracing.field_curves","text":"field_curves(W::Aberration, s::SystemOrRayBasis; k = k, kwargs...)\n\nPlot the third order longitudinal astigmatic field curves. Requires using a Makie backend. k controls the discretization / number of plot elements.\n\nH on the plot refers to the normalized field parameter.\n\nP, T, & S on the plot refer to the Petzval field, the Tangential field, and the Sagittal field.\n\nSee also: percent_distortion, rayfan, spot_diagram, wavefan.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.flatten","page":"API","title":"OpticalRayTracing.flatten","text":"flatten(M::TransferMatrix)\n\nReturn the cardinal points for the input vertex matrix.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.full_trace","page":"API","title":"OpticalRayTracing.full_trace","text":"full_trace(system, H, [k_rays], [focus] = BFD)\nfull_trace(surfaces, ray_basis)\n\nSample the pupil using real rays to compute the transverse ray errors at the focus position along with the RMS spot size. Returns a RealRayError holding the x & y ray error vectors along with the corresponding r & t pupil polar coordinates.\n\nThe RMS spot size is computed from the centroid rather than the chief ray.\n\nH is the normalized field parameter while k_rays refers to the number of rays.\n\nSee also: raytrace, wavegrad.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.incidences","page":"API","title":"OpticalRayTracing.incidences","text":"incidences(system)\n\nCompute the paraxial incidence angles over the system. Returns a four column matrix with the first two columns referring to the optical angles ni & nī for the marginal & chief ray, respectively, and the last two columns referring to the physical angles i, ī.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.optimize","page":"API","title":"OpticalRayTracing.optimize","text":"optimize(system, v, constraints, [aberr], [weights])\n\nOptimize an optical system such that the surface layout over the indices v minimizes the weighted aberrations provided in aberr subject to the given constraints.\n\nSee also: solve.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.percent_distortion","page":"API","title":"OpticalRayTracing.percent_distortion","text":"percent_distortion(W::Aberration, s::SystemOrRayBasis; k = k, kwargs...)\n\nPlot the percent distortion for the given system of aberrations. Requires using a Makie backend. k controls the discretization / number of plot elements.\n\nH on the plot refers to the normalized field parameter.\n\nSee also: field_curves, rayfan, spot_diagram, wavefan.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.rayfan","page":"API","title":"OpticalRayTracing.rayfan","text":"rayfan(W::Aberration, s::SystemOrRayBasis; k = k, kwargs...)\n\nPlot the third order ray intercept curves for the given system of aberrations. Requires using a Makie backend. k controls the discretization / number of plot elements.\n\nH on the plot refers to the normalized field parameter and can be adjusted with a slider.\n\nSee also: field_curves, percent_distortion, spot_diagram, wavefan.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.rayplot","page":"API","title":"OpticalRayTracing.rayplot","text":"rayplot(system)\nrayplot(surfaces, ray_basis)\n\nPlots the given system or ray bundle using Makie; requires installation of a Makie backend such as GLMakie.\n\nSee also: rayplot!.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.rayplot!","page":"API","title":"OpticalRayTracing.rayplot!","text":"rayplot!(system)\nrayplot!(surfaces, ray_basis)\n\nMutating version of rayplot which draws on top of the active figure.\n\nSee also: rayplot.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.raypoints","page":"API","title":"OpticalRayTracing.raypoints","text":"raypoints(marginal::ParaxialRay{Marginal}, chief::ParaxialRay{Chief})\n\nReturn the coordinates for the given ray basis; useful for manual plotting.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.raytrace","page":"API","title":"OpticalRayTracing.raytrace","text":"raytrace(surfaces, y, ω, [a]; clip = false)\nraytrace(lens::Lens, y, ω)\n\nTrace a paraxial ray with height y and angle / slope ω = nu returning a ParaxialRay{Tangential} holding the ynu matrix.\n\nIf a set of aperture semi-diameters a is specified and clip = true any blocked ray will result in NaN in the trace matrix.\n\n\n\nraytrace(system::System, ȳ, s)\n\nTrace the paraxial marginal and chief ray through a given system for a given object height and distance from the objective; these are signed quantities.\n\nSee also: solve, incidences.\n\n\n\nraytrace(surfaces::AbstractMatrix, y, U, ::Type{RealRay})\n\nTrace a real ray through the surfaces with initial height y and initial angle U.\n\n\n\nraytrace(surfaces::AbstractMatrix, y, x, U, V, ::Type{Vector{RealRay}})\n\nTrace a real ray through the lens in three dimensions. U refers to the angle the ray makes with the optical z-axis in the y-direction and V to the angle it makes with the z-axis in the x-direction.\n\nThis method returns a two-tuple of vectors holding the x and y coordinates at each surface.\n\nSee also: trace_marginal_ray, full_trace.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.reverse_transfer","page":"API","title":"OpticalRayTracing.reverse_transfer","text":"reverse_transfer(M::TransferMatrix, v::Vector, τ′, τ)\n\nTransfer an input [y, nu] vector in the reverse direction, extending by image & object space distances τ′, τ.\n\nSee also: transfer.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.scale!","page":"API","title":"OpticalRayTracing.scale!","text":"scale!(M::Lens)\n\nConvert the second column powers from dioptres to inverse millimeters.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.solve","page":"API","title":"OpticalRayTracing.solve","text":"solve(surfaces::Matrix, a::Vector, h′::Float64)\nsolve(layout::Layout, a, h′)\nsolve(lens::Lens, a, h′)\n\nSolve a lens, returning a System holding the relevant properties. a denotes the clear aperture semi-diameters while h′ indicates the image height.\n\nFields are:\n\nf: effective focal length;\nEBFD: effective back focal distance;\nEFFD: effective front focal distance;\nN: f-number;\nFOV: full field of view in degrees;\nstop: surface matrix index denoting the aperture stop;\nEP: entrance pupil containing fields: D: diameter, t: distance from the front vertex;\nXP: exit pupil containing fields: D: diameter, t: distance from the back vertex;\nmarginal: marginal ray;\nchief: chief ray;\ntrace: the full yu ray trace for the marginal & chief rays;\nH: Lagrange invariant;\nP1: front principal plane location w.r.t the front vertex;\nP2: back principal plane location w.r.t the back vertex;\nPN: nodal point shift from the principal points;\nM: the vertex matrix;\nlens: Lens of the system;\nlayout: the surface layout / prescription if specified.\n\nSee also: raytrace, incidences.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.spot_diagram","page":"API","title":"OpticalRayTracing.spot_diagram","text":"spot_diagram(W::Aberration, s::SystemOrRayBasis; k = k, kwargs...)\n\nPlot the spot diagram over the image plane using third order aberration data. Requires using a Makie backend. k controls the discretization / number of plot elements.\n\nH on the plot refers to the normalized field parameter and can be adjusted with a slider.\n\nSee also: field_curves, percent_distortion, rayfan, spot_diagram.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.trace_chief_ray","page":"API","title":"OpticalRayTracing.trace_chief_ray","text":"trace_chief_ray(lens::Lens, stop::Int, marginal::ParaxialRay{Marginal}, h′)\n\nFind the paraxial chief ray for the given lens.\n\nSee also: solve.\n\n\n\ntrace_chief_ray(system::System; atol = sqrt(eps()))\n\nFind the real chief ray for the given surfaces and system.\n\nSee also: trace_marginal_ray, raytrace.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.trace_marginal_ray","page":"API","title":"OpticalRayTracing.trace_marginal_ray","text":"trace_marginal_ray(lens::Lens, a, [ω = 0.0])\n\nFind the paraxial marginal ray for the given lens and aperture sizes.\n\nSee also: solve.\n\n\n\ntrace_marginal_ray(system::System; atol = sqrt(eps()))\n\nFind the real marginal ray for the given surfaces and system.\n\nSee also: trace_chief_ray, raytrace.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.transfer","page":"API","title":"OpticalRayTracing.transfer","text":"transfer(M::TransferMatrix, v::Vector, τ, τ′)\n\nTransfer an input [y, nu] vector, extending by object & image space distances τ, τ′.\n\nSee also: reverse_transfer.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.vignetting","page":"API","title":"OpticalRayTracing.vignetting","text":"vignetting(system, [a = system.a])\n\nPerform a vignetting analysis on the System for the given aperture sizes.\n\nDetermines the maximum FOVs corresponding to those sizes as well as returning a Vignetting data structure holding a semi-diameter matrix in its M field with columns corresponding to conditions:\n\ninput;\nstop limited;\nunvignetted;\nhalf-vignetted;\nfully vignetted.\n\nThe fields of view are stored in the FOV field with rows corresponding to the unvignetted, half-vignetted, and fully vignetted cases and the columns corresponding to the full fields of view in degrees, paraxial chief ray slopes, and image heights, respectively.\n\nsystem can also be a traced RayBasis corresponding to the marginal & chief rays of a non-collimated beam for an object not at infinity.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.wavefan","page":"API","title":"OpticalRayTracing.wavefan","text":"wavefan(W::Aberration; k = k, kwargs...)\n\nPlot the input aberrations as a a composite wavefront error over the pupil in the tangential and sagittal directions. Requires using a Makie backend. k controls the discretization / number of plot elements.\n\nH on the plot refers to the normalized field parameter and can be adjusted with a slider.\n\nSee also: field_curves, percent_distortion, rayfan, spot_diagram.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpticalRayTracing.wavegrad","page":"API","title":"OpticalRayTracing.wavegrad","text":"wavegrad(ε::RealRayError, [λ] = 587.5618e-6)\n\nReturn a two-tuple with the wavefront error partial derivative vectors in x & y.\n\nSee also: full_trace.\n\n\n\n\n\n","category":"function"}]
}
